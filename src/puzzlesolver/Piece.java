package puzzlesolver;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import puzzlesolver.enums.Direction;
import puzzlesolver.enums.PieceType;

/**
 * A class to represent a 4-sided puzzle piece.
 *
 * This piece has a type that MUST be determined during solution and CANNOT be provided to it or
 * determined during generation.
 *
 * This can also represent potential pieces, which are pieces generated by the solver which have 1-4
 * known sides and potentially multiple piece types.
 */
public class Piece {

  public static class Builder {

    private final Side[] sides = new Side[4];

    /**
     * Sets this piece's side in the given direction to the given side.
     *
     * @param side the side to be added
     * @param dir  the direction of the side in this piece
     */
    public Builder setSide(Side side, Direction dir) {
      sides[dir.ordinal()] = side.copy();
      return this;
    }

    /**
     * Builds a {@link Piece} from this builder's sides.
     */
    public Piece build() {
      return new Piece(sides);
    }
  }

  /**
   * Sides are ordered in the same way as {@link Direction}: NORTH, EAST, SOUTH, WEST.
   */
  private final Side[] sides;
  private final PieceType[] pieceTypes;

  /**
   * Constructs a new Piece with the given 4 sides.
   *
   * @param sides array of sides, length MUST be 4
   */
  private Piece(Side[] sides) {
    this.sides = sides;
    this.pieceTypes = findPieceTypes();
  }

  /**
   * Gets a clone of the side of this piece in the given direction.
   *
   * @param dir the direction of the piece to be retrieved
   * @return a clone of the side in the given direction
   */
  public Side getSide(Direction dir) {
    return sides[dir.ordinal()] != null ? sides[dir.ordinal()].copy() : null;
  }

  /**
   * Gets the {@link PieceType} type of this piece. This was calculated upon construction of the
   * object.
   *
   * @return the type of this piece
   */
  public PieceType[] getPieceTypes() {
    return pieceTypes.clone();
  }

  private PieceType[] findPieceTypes() {
    List<PieceType> types = new ArrayList<>(PieceType.values().length);
    for (PieceType pieceType : PieceType.values()) {
      if (pieceType.canBeType(this)) {
        types.add(pieceType);
      }
    }
    return types.toArray(new PieceType[types.size()]);
  }

  /**
   * Is this piece <i>definitely</i> of the given type?
   *
   * @param pieceType the type to check for
   * @return true is the given type is the <i>only</i> type that this one can be, false otherwise
   */
  public boolean definitelyType(PieceType pieceType) {
    return pieceTypes.length == 1 && pieceTypes[0] == pieceType;
  }
}
